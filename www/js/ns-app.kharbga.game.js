/* Requires/Uses: 
 * - jquery.js JQuery lib
 * - kharbga.js Kharbga Engine lib (generated by tns)
 * - ns-app-kharbga.utils.js
 * - 
 * 
 * Html file/View to include the following elements:
 * - board -  the Kharbga board element
 * - message  location to 
 */
/* Kharbga Game Controller */
var KharbgaGameController = function () {
    // the board game and ui element
    var board,
        boardEl = $('#board');

  //  this.serverProxy = serverProxy;

    // flag for turning on/off logging 
    var loggingOn = true; 

    // the local game state
    var gameState = {
        selectedSource: "",
        activeGame: false,
        lastReplayPosition: -1,
        firstComputerSetting: true,
        computer_is_playing: false,
    };
    
    /**
     * play options for the computer
     */
    var playOptions = {
        useServer: false,
        randomSetting: true,
        firstSettingMustIncludeMalhaAdjacent: true,
        randomMove: true,
        searchMovesThatCaptureOpponent: true,
        searchMovesThatSaveSelf: true,
        preferMovesThatCaptureOverMovesThatSave: true,
        displayGameOverDialog: false

    };

    var lastMove = {
        isAttacker: true,
        isSetting: true,
        fromRequired: "", 
        from: "",
        to : "",
        captured: "",
        exchanged: "",
        resigned: false,
        exchangeRequest: false
    };

    var currentMove ={
        isAttacker: true,
        isSetting: true,
        fromRequired: "", 
        from: "",
        to: "",
        captured: "",
        exchanged: "",
        resigned: false,
        exchangeRequest: false,
        reset: function () {
            currentMove.isSetting = null;
            currentMove.isAttacker = null;
            currentMove.fromRequired = ""; 
            currentMove.from = "";
            currentMove.to = "";
            currentMove.captured = "";
            currentMove.exchanged = "";
            currentMove.resigned = false;
            currentMove.exchangedRequest = false;
        },
        copyToLast: function () {
            lastMove.fromRequired = currentMove.fromRequired;
            lastMove.from = currentMove.from;
            lastMove.to = currentMove.to;
            lastMove.isAttacker = currentMove.isAttacker;
            lastMove.isSetting = currentMove.isSetting;
            lastMove.exchanged = currentMove.exchanged;
            lastMove.captured = currentMove.captured;
            lastMove.resigned = currentMove.resigned;
            lastMove.exchangeRequest = currentMove.exchangeRequest;
        },
        copyToLastAndReset: function () {
            currentMove.copyToLast();
            currentMove.reset();
        }
    };

    var userOptions = {
        highlightLastMove: true,
        highlightLastMoveMilliSecondsBeforeTimeout: 2000,
        displayLastMove: true
    };

    /* the game events */
    /**
     * Handler for the local engine when a new game is started
     * @param {any} eventData -- the event data
     */
    function onNewGameStarted(eventData) {
        console.log("%s - event: onNewGameStarted - source: %s ", getLoggingNow(), eventData.source.fen());

        $('#message').html("<div class='alert alert-success'>Started a new game.  </div>")

        gameState.activeGame = true;
        $('#currentGamePanel').show();

        // update the board with current game state
        updateBoard(eventData.source);

        if (userOptions.displayLastMove)
            currentMove.copyToLastAndReset();
        
        checkBoardAndPlayIfComputer();
    }
    /**
     * private event handler when a new player turn
     * @param {any} eventData: the event data
     */
    function onNewPlayerTurn(eventData) {
        console.log("%s - event: onNewPlayerTurn - player: %s", getLoggingNow(), eventData.player);

        $('#player-turn').html(Kharbga.PlayerRole[eventData.player.role]);
      //  currentPlayer = eventData.player;

        var message = "<div class='alert alert-success'>It is the turn  of the <strong>" +
            Kharbga.PlayerRole[eventData.player.role];

        //TODO: fix so not to rely on the server for this
        // 
     /*   if (appClientState.player != null && !appClientState.player.IsSpectator) {
            if (appClientState.player.IsAttacker === true && game.turn() == 'a')
                message += " (Your turn) ";

            if (appClientState.player.IsAttacker === false && game.turn() == 'd')
                message += " (Your turn) ";
        }
   */
        message += "</strong> to play </div>";
        $('#message').html(message);
    

        $("#move-message").val('');  // clears the last move message

        updateBoard(eventData.source);
        currentMove.copyToLastAndReset();

        if (userOptions.highlightLastMove) {
            setTimeout(function () {
                removeSelectedCells();
               // removeLastMoveHighlighting();
            },userOptions.highlightLastMoveMilliSecondsBeforeTimeout);           
        }

        checkBoardAndPlayIfComputer();        
    }
  
    /**
     * handler for when a setting is completed
     * @param {any} eventData: the event data
     */
    function onNewSettingCompleted(eventData) {
        console.log("%s - event: onNewSettingCompleted - cell %s ", getLoggingNow(), eventData.targetCellId);
        currentMove.isSetting = true;
        if (game.turn() == 'a') {
            $('#attackerSettings').append($('<option>', {
                value: game.getAttackerScore(),
                text: eventData.targetCellId
            }));
            currentMove.isAttacker = true;
        }
        else {
            $('#defenderSettings').append($('<option>', {
                value: game.getDefenderScore(),
                text: eventData.targetCellId
            }));
            currentMove.isAttacker = false;
        }
        var message = "<div class='alert alert-success'>It is the turn  of the <strong>" + Kharbga.PlayerRole[eventData.player.role];

    /*    //TODO: fix so not to rely on the server for this
        // 
        if (appClientState.player.IsAttacker === true && game.turn() == 'a')
            message += " (Your turn) ";

        if (appClientState.player.IsAttacker === false && game.turn() == 'd')
            message += " (Your turn) ";
*/
        message+=" </strong>to set the 2nd piece. </div>"
        $('#message').html(message);


        updateBoard(eventData.source);

        currentMove.from = "spare";
        currentMove.to = eventData.targetCellId;
   
        /* highlight the previous move */
        var source = boardEl.find('.square-' + eventData.targetCellId);
        source.addClass('highlight-move');
        
         checkBoardAndPlayIfComputer();      
    }

    /**
     * Handler for when the settings phase is completed
     * @param {any} eventData: the event data
     */
    function onSettingsCompleted(eventData) {
        console.log("%s - event: onSettingsCompleted - final board state: %s", getLoggingNow(), eventData.source.fen());

        var message = "<div class='alert alert-success'>The setting phase is now completed.  It is the Attacker turn to move a piece to the middle cell. <strong>";

     /*   if (appClientState.player.IsAttacker === true && game.turn() == 'a')
            message += " (Your turn). ";

        if (appClientState.player.IsAttacker === false && game.turn() == 'd')
            message += " (Your turn). ";
        message += " </strong></div>"
*/
        $('#message').html(message);



        $('#state').html(Kharbga.GameState[eventData.source.getState()]);

        updateScores(eventData.source);

        // display the exchange request fields
        $('.exchangeRequest').show();

        boardEl.find('.square-d4').removeClass('highlight-malha');

        // setup the game players
       // game.setPlayerNames(appClientState.player.userScreenName, appClientState.opponentPlayer.userScreenName);

        checkBoardAndPlayIfComputer();
    }

    /**
     * Handler for when a new move is started
     * @param {any} eventData: the event data
     */
    function onNewMoveStarted(eventData) {
        // not used 
    }

    /**
     * handler for when a move is completed
     * @param {any} eventData: the event data
     */
    function onNewMoveCompleted(eventData) {
        console.log("%s - event: onNewMoveCompleted - game position: %s - from: %s - to: %s  ",
            getLoggingNow(), eventData.source.fen(), eventData.from.id, eventData.to.id);

        currentMove.isSetting = false;
        currentMove.from = eventData.from.id;
        currentMove.to = eventData.to.id;

        // remove source highlighting
         var sourceRequired = boardEl.find('.highlight-source');
         sourceRequired.removeClass('highlight-source');

        boardEl.find('.highlight-captured').removeClass('highlight-captured');

        /* highlight the previous move */
        var source = boardEl.find('.square-' + eventData.from.id);
        source.addClass('highlight-move');
        var target = boardEl.find('.square-' + eventData.to.id);
        target.addClass('highlight-move');

        
        updateBoard(eventData.source);

        if (game.turn() == 'a') {
            $('#attackerMoves').append($('<option>', {
                value: game.getAttackerMoveNumber(),
                text:  eventData.from.id + '-' + eventData.to.id
            }));
            currentMove.isAttacker = true;
        }
        else {
            $('#defenderMoves').append($('<option>', {
                value: game.getDefenderMoveNumber(),
                text: eventData.from.id + '-' + eventData.to.id
            }));
            currentMove.isAttacker = false;
        }      
    }

    /**
     * Handler for when a move is completed and the same player must continue moving using the same piece
     * @param {any} eventData: the event data
     */
    function onNewMoveCompletedContinueSamePlayer(eventData) {
        console.log("%s - event: onNewMoveCompletedContinueSamePlayer - source: %s - from %s - to: %s ",
            getLoggingNow(), eventData.source.fen(), eventData.from.id, eventData.to.id);

        $('#message').html("<div class='alert alert-success'>Same player must continue playing using the same soldier now on: <strong> " +
            eventData.targetCellId  + "</strong>. There are still pieces that could be captured.  </div>" );

        currentMove.isSetting = false;
        currentMove.copyToLast();
        currentMove.fromRequired = eventData.targetCellId;
        // player must play this piece   
     
        var moveSourceRequired = eventData.targetCellId;
        // highlight the piece required for moving
        var sourceRequired = boardEl.find('.square-' + moveSourceRequired);
        sourceRequired.addClass('highlight-source');

        updateScores(eventData.source);

        if (game.turn() === 'a') {
            $('#attackerMoves').append($('<option>', {
                value: game.getAttackerMoveNumber(),
                text: eventData.from.id + '-' + eventData.to.id
            }));
            currentMove.isAttacker = true;
        }
        else {
            $('#defenderMoves').append($('<option>', {
                value: game.getDefenderMoveNumber(),
                text: eventData.from.id + '-' + eventData.to.id
            }));
            currentMove.isAttacker = false;
        }

        checkBoardAndPlayIfComputer(moveSourceRequired);
    }

    /**
     * handler for the player selecting a cell and not moving and staying the same cell. This could indicate a player
     * selecting a piece for exchange
     * @param {any} eventData -- the action data
     */
    function onNewMoveCanceled(eventData) {
        console.log("%s - event: onNewMoveCanceled - target Cell Id: %s ", getLoggingNow(), eventData.targetCellId); 
    }

    /**
     * Handler for an invalid move
     * @param {any} eventData - the event data
     */
    function onInvalidGameMove(eventData) {
        console.log("%s - event: onInvalidMove - source: %s - from %s - to: %s ",
            getLoggingNow(), eventData.source.fen(), eventData.from.id, eventData.to.id);
    }

    /**
     * Handler for when the game is over
     * @param {any} eventData - the game event info
     */
    function onWinnerDeclared(eventData) {
        console.log("%s - event: onWinnerDeclared - winner: %s ", getLoggingNow(), eventData.player);
        $('#message').html("<div class='alert alert-success'><strong>Game Over. Winner is: " + Kharbga.PlayerRole[eventData.player.role] + " </strong></div>")

        $('#state').html(Kharbga.GameState[eventData.source.getState()]);

        updateBoard(eventData.source);

        currentMove.copyToLastAndReset();
        currentMove.reset();

        if (userOptions.highlightLastMove) {
            setTimeout(function () {
                removeSelectedCells();
                removLastMoveHighlighting;
            }, userOptions.highlightLastMoveMilliSecondsBeforeTimeout);
        }
       // $('#startGameBtn').show();
       // $('#loadSetting1').hide();     
    }

    /**
     * Handler when an untouchable soldier is selected
     * @param {any} eventData - the event data
     */
    function onUntouchableSelected(eventData) {
        console.log("%s - event: onUntouchableSelected - cell: %s", getLoggingNow(), eventData.targetCellId);
     
        var exchangeSquare = boardEl.find('.square-' + eventData.targetCellId);
        exchangeSquare.addClass('highlight-exchange');

        updateMoveFlags(eventData.source.move_flags());

    }

    /**
     * Handler for when  an exchange request is canceled
     * @param {any} eventData - the event data
     */
    function onUntouchableExchangeCanceled(eventData) {
        console.log("%s - event: onUntouchableExchangeCanceled - source: %s ", getLoggingNow(), eventData.source);
        $('#message').html("<div class='alert alert-warning'>Exchange Request Canceled</div>")

        updateScores(eventData.source);
        updateMoveFlags(eventData.source.move_flags());

        boardEl.find('.highlight-exchange').removeClass('highlight-exchange');
    }

    /**
     * Handler for when an exchange request is completed
     * @param {any} eventData - the event data
     */
    function onUntouchableExchangeCompleted(eventData) {
        console.log("%s - event: onUntouchableExchangeCompleted - source: %s ", getLoggingNow(),eventData.source);
        $('#message').html("<div class='alert alert-success'>Exchange Request Completed</div>")


     //   board.position(game.fen(), false);
        updateScores(eventData.source);
        var moveFlags = game.move_flags();
        updateMoveFlags(moveFlags);

        // remove the highlighting after a couple of seconds
        setTimeout(removLastMoveHighlighting, 2000);
    }

    /**
     * Handler for when a player sets on the Malha during setting mode
     * @param {any} eventData - the event data
     */
    function onInvalidSettingMalha(eventData) {
        console.log("%s - event: onInvalidSettingMalha - targetCellId: %s ", getLoggingNow(), eventData.targetCellId);
        $('#message').html("<div class='alert alert-danger'>Setting on middle cell (Malha) is not allowed</div>")

    }

    /**
     * Handler for when a player sets on an occupied cell
     * @param {any} eventData - the event data
     */
    function onInvalidSettingOccupied(eventData) {
        console.log("%s - event: onInvalidSettingOccupied - targetCellId: %s ", getLoggingNow(), eventData.targetCellId);

        $('#message').html("<div class='alert alert-danger'>Setting on an occupied cell is not allowed</div>")
    }

    /* Board Events */
    function onInvalidMove(eventData) {
        console.log("%s - board event: onInvalidMove - target: %s - type : %s ",
            getLoggingNow(), eventData.targetCellId, Kharbga.BoardMoveType[eventData.type]);

        $('#message').html("<div class='alert alert-danger'>Invalid Move " + Kharbga.BoardMoveType[eventData.type] +" </div>")
    }

    function onValidMove(eventData) {
        console.log("%s - board event: onValidMove - target: %s ", getLoggingNow(), eventData.targetCellId);
    }

    function onCapturedPiece(eventData) {
        console.log("%s - board event: onCapturedPiece - target: %s ", getLoggingNow(), eventData.targetCellId);

        //  board.move(eventData.targetCellId + "-spare");
        // remove original piece from source square
        //srcSquareEl.find('.' + CSS.piece).remove();
        var capturedSquare = boardEl.find('.square-' + eventData.targetCellId);
        capturedSquare.addClass('highlight-captured');
       // capturedSquare.find('.' + pieceClass).remove();

        $('#move-captured').append(" " + eventData.targetCellId);
        currentMove.captured += " ";
        currentMove.captured += eventData.targetCellId;

        updateBoard(game);
    }

    function onExchangedPiece(eventData) {
        console.log("%s - board event: onExchangedPiece - target: %s", getLoggingNow(), eventData.targetCellId);

    
        var exchangedSquare = boardEl.find('.square-' + eventData.targetCellId);
        exchangedSquare.addClass('highlight-exchange');

        $('#move-exchanged').append(" " + eventData.targetCellId);
        currentMove.exchanged += " ";
        currentMove.exchanged += eventData.targetCellId;

        updateBoard(game);

    }

    function onPlayerPassed(eventData) {
        console.log("%s - board event: onPlayer Passed - target: %s ", getLoggingNow(), eventData.player.Name);
        $('#message').html("<div class='alert alert-warning'>Player passed - Player: " + eventData.player.Name + " </div>")
    }


    // Setup the game events to pass to the game object
    var gameEvents = {
        newGameStartedEvent: onNewGameStarted,
        newPlayerTurnEvent: onNewPlayerTurn,
        newSettingCompletedEvent: onNewSettingCompleted,
        settingsCompletedEvent: onSettingsCompleted,
        newMoveStartedEvent: onNewMoveStarted,
        newMoveCompletedEvent: onNewMoveCompleted,
        newMoveCompletedContinueSamePlayerEvent: onNewMoveCompletedContinueSamePlayer,
        newMoveCanceledEvent: onNewMoveCanceled,
        winnerDeclaredEvent: onWinnerDeclared,
        untouchableSelectedEvent: onUntouchableSelected,
        untouchableExchangeCanceledEvent: onUntouchableExchangeCanceled,
        untouchableExchangeCompletedEvent: onUntouchableExchangeCompleted,
        invalidSettingMalhaEvent: onInvalidSettingMalha,
        invalidSettingOccupiedEvent: onInvalidSettingOccupied,
        invalidMoveEvent: onInvalidGameMove, 
        playerPassedEvent: onPlayerPassed,
        moveProcessed: onMoveProcessed
    };

    // Setup the board events
    var boardEvents = {
        invalidMoveEvent: onInvalidMove,
        validMoveEvent: onValidMove,
        capturedPieceEvent: onCapturedPiece,
        exchangedPieceEvent: onExchangedPiece

    };

    var serverEventHanlders = {
        message: onServerMessage
    }; 
    this.getServerEventsHandlers = function () {

        return serverEventHanlders;

    };
    
    // The current game
    var game = new Kharbga.Game(gameEvents, boardEvents); 
  
    var squareClass = 'square-55d63',
        pieceClass = 'piece-417db',
        squareToHighlight,
        colorToHighlight;

    var onDragMove = function(newLocation, oldLocation, source, piece, position, orientation) {
        /*      console.log("New location: " + newLocation);
              console.log("Old location: " + oldLocation);
              console.log("Source: " + source);
              console.log("Piece: " + piece);
              console.log("Position: " + KharbgaBoard.objToFen(position));
              console.log("Orientation: " + orientation);
              console.log("--------------------");
              console.log("game state: " + game.getState());
              console.log("game is in setting mode: " + game.isInSettingMode());
          */
    };

    function onServerMessage(msg) {
        console.log("on server message: %s", msg);
        $('#message').html(msg);
    }

    // do not pick up pieces if the game is over
    // only pick up pieces for the side to move
    var onDragStart = function(source, piece, position, orientation) {
        // check if settings is over and selected piece is spare
        if (game.game_setting_over() === true && source === 'spare') {
            $('#message').html("<div class='alert alert-warning'>Game setting is done. You could only move pieces on the board now.</div>")
            return false;
        }

        // check if setting is not over and selected piece is on the board
        if (game.game_setting_over() === false && source !== 'spare') {
            $('#message').html("<div class='alert alert-warning'>You are not allowed to move pieces on the board until the game setting is completed.</div>")

            return false;
        }

        if (!allowedToMove())
            return; 

        return validSource(source, piece);
    };

    /**
     * Checks if the current player can make a move 
     */
    function allowedToMove() {
        if (game.game_over() === true)
            return false;     

/* TODO review 
        if (typeof appClientState.player == 'undefined' || appClientState.player == null) {
            $('#message').html("<div class='alert alert-info'>Please start or join a game to be able to play.</div>");
            return false;
        }
        if (appClientState.player.IsSpectator === true) {
            $('#message').html("<div class='alert alert-warning'>As a spectator you are not allowed to make any moves. You could however post comments to the players.</div>");
            return false;
        }
        // check if allowed to make the move
        if (game.turn() === 'a' && appClientState.player.IsAttacker !== true) {
            $('#message').html("<div class='alert alert-warning'>It is the attacker's turn to play.</div>");
            return false;
        }
        if (game.turn() === 'd' && appClientState.player.IsAttacker !== false) {
            $('#message').html("<div class='alert alert-warning'>It is the defender's turn to play.</div>");
            return false;
        }
   */

        return true;
    }


    /**
     * Checks if the source square is valid depending on the current game state
     * @param {any} source -- the selected square
     * @param {any} piece  -- the piece selected
     */
    function validSource(source, piece) {
        if (source === "" || source === "spare")
        {
            if (game.is_in_moving_state() === false)
                return true;
            else
                return false; 
        }

        if (game.is_in_moving_state() === true) {        
            // check if selected is occupied by current player
            if (game.is_occupied_current_player(source) === false) {
                $('#message').html("<div class='alert alert-warning'>Cell <strong>"+ source + "</strong> is not occupied by a solider. You could only move using your soldiers.</div>")

                return false;
            }

            // check if source piece is surrounded -- return false
            if (game.is_surrounded_piece(source) === true) {
                $('#message').html("<div class='alert alert-warning'>You could only move pieces that have free/open adjacent cells.</div>")

                return false;
            }

            var moveSourceRequired = game.move_source_required();
            // check if a given source piece must be played
            if (moveSourceRequired.length != 0 && source !== moveSourceRequired) {
                $('#message').html("<div class='alert alert-info'>Please continue moving using solider on " + moveSourceRequired + "</div>")
                return false;
            }
        }

        return true;
    }

    /**
     * Handler for when a piece is dropped on the board
     * @param {any} source -- source location
     * @param {any} target -- target location
     * @param {any} piece  -- the piece selected
     * @param {any} newPos -- the new position
     * @param {any} oldPos -- the old position of the board
     * @param {any} orientation -- the board orientation
     */
    var onDrop = function(source, target, piece, newPos, oldPos, orientation) {
        console.log("onDrop - from: %s - to: %s ", source, target);

        clearLastMoveInfo();
        $('#gameMove').html(source + "-" + target);
       
        var ret = processAction(source, target);
        // updateStatus();
        if (ret === false) return 'snapback';
    };

    /**
     * Process the user action
     * @param {any} source -- the source piece
     * @param {any} target -- the target piece
     */
    function processAction(source, target) {
        var ret = false;
        var gameMove = {};

        gameMove.Message = $("#user-message").val();

        gameMove.Resigned = $('#abandonCheckbox').is(':checked');
        gameMove.ExchangeRequest = false;
        gameMove.IsAttacker = false;
        if (game.turn() === 'a') {
            gameMove.ExchangeRequest = $('#exchangeRequestAcceptedCheckbox').is(':checked');
            gameMove.IsAttacker = true;
        }
        else {
            gameMove.ExchangeRequest = $('#exchangeRequestCheckbox').is(':checked');
        }
        gameMove.IsSetting = false;

        gameMove.BeforeFEN = game.fen();
        gameMove.From = source;
        gameMove.To = target;

        if (game.is_in_moving_state()) {
            if (source == target)
            {
                removeSelectedCells(); 
                gameState.selectedSource = "";

                return false;  // same cell is selected
            }

            // check if valid move
            if (game.valid_move(source, target) === false) {

                removeSelectedCells();
                gameState.selectedSource = "";
                $('#message').html("<div class='alert alert-warning'>Invalid move from " + source + " to " + target +". You may only move your soldiers to adjacent free cells orthogonally and not diagonally.</div>")
    
                return false;
            }

            ret = game.processMove2(gameMove, gameEvents);
        }
        else {
            if (game.is_in_setting_state()) {
                gameMove.IsSetting = true;
                ret = game.processSetting(target);
                onMoveProcessed(ret, gameMove);
            }
            else {
                ret = false;
            }
        }

        return ret; 
    }

    /**
     * Callback for when the action is processed by the game engine
     * @param {any} ok - the processing status
     * @param {any} gameMove - the move is processed
     */
    function onMoveProcessed(ok, gameMove) {
        if (ok === false)
            return;

        lastMoveId = createMoveId();
        // submit to the server
    /*    if (appClientState.serverGameId !== "" && appClientState.useServer === true) {
            // notify server pf the setting
            gamesHubProxy.server.recordMove(appClientState.serverGameId, appClientState.userScreenName,
                gameMove.IsAttacker, gameMove.IsSetting, gameMove.From, gameMove.To, gameMove.Resigned, gameMove.ExchangeRequest,
                gameMove.BeforeFEN, game.fen(), gameMove.Message, lastMoveId,
                lastMove.captured, lastMove.exchanged
            ).done(function () {
                console.log('%s - Done server Invocation of recoredMove ( moveId : %s)', getLoggingNow(), lastMoveId);
                completeMoveProcessed();

            })
                .fail(function (error) {
                    console.log('%s - Invocation of recordMove ( moveId : %s) failed. Error: %s ', getLoggingNow(), lastMoveId, error);
                });
        }
        else {
            
        }
      */
        completeMoveProcessed(); 
    }

    function completeMoveProcessed() {
        $("#user-message").text("");
        // 
        //play sound here
        playSound(); 

        // good place to reset the current move
        // check if game is over
        if (game.game_over()) {
            // trigger server updating the game status into the server
            saveGame(game);
        }

    }

    var onMoveEnd = function () {
        //updateBoard()

    };

    //Indicates that the current player had already selected this piece
    
    /**
     * handler for when click  a cell for setting or for a move (from or to)
     * @param {any} square -- the clicked square
     * @param {any} piece  -- the piece on the square
     * @param {any} postion -- current game position
     * @param {any} orientation -- the game orientation 
     */
    var onClick = function (square, piece, position, orientation) {
        console.log("%s - onClick - square: %s - piece: %s ", getLoggingNow(), square, piece);

        // check if allowed to move
        if (!allowedToMove())
            return;

        var source = "";

        if (game.is_in_moving_state()) {
            if (gameState.selectedSource == "") {
                // Checks if the square is valid
                if (!validSource(square, piece))
                    return;
                gameState.selectedSource = square;
                removeSelectedCells(); // from the previous move
                $('#message').html("<div class='alert alert-success'>Selected cell <strong> " + square + " </strong>for moving...</div>")
                // highlight square
                highlightSelected(square);
                return;
            }
            source = gameState.selectedSource;
        }
        else {
            source = "spare";
        }

        var target = square;
        if (source === target) {
            $('#message').html("<div class='alert alert-success'>Canceled cell selection for square <strong> " + appClientState.selectedSource + " </strong>for moving...</div>")
            removeSelectedCells(); // from the previous move
            gameState.selectedSource = "";
            return;
        }

        // Checks if the source is valid
        //   if (!validSource(source, piece))
        //       return;

        //to do : add check for target


        highlightTarget(square);
        $('#move-captured').empty();
        $('#move-exchanged').empty();

        var ret = processAction(source, target);

        if (ret) {
            $('#gameMove').html(source + "-" + target);

            setTimeout(updateBoard, 20);  // update the board after handling on Click event
            //   updateBoard();
            //    removeSelectedCells();
        }
        gameState.selectedSource = ""; //reset after the move
    };

    /**
       * handler for when double clicking a cell for setting or for a move (from or to)
       * @param {any} target -- the target square
       * @param {any} piece  -- the piece on the square
       * @param {any} postion -- current game position
       * @param {any} orientation -- game orientation 
       */
    var onDoubleClick = function (target, piece, position, orientation) {
        console.log("%s - onDoubleClick - target: %s - piece: %s ", getLoggingNow(), target, piece);

    };

    function highlightSelected(square) {
        var squareEl =  boardEl.find('.square-' + square);
        squareEl.addClass('highlight-move');

     //   var background = '#a9a9a9';
      //  if (squareEl.hasClass('black-3c85d') === true) {
            background = '#696969';
     //   }

     //   squareEl.css('background', background);
    }
    function highlightTarget(square) {
        var squareEl = boardEl.find('.square-' + square);
        squareEl.addClass('highlight-move');

        var background = '#a9a9a9';
        if (squareEl.hasClass('black-3c85d') === true) {
            background = '#696969';
        }

     //   squareEl.css('border-color', background);
    }

    var removeSelectedCells = function () {
      
        boardEl.find('.highlight-move').removeClass('highlight-move');

     //   boardEl.find('.highlight-move').css('background', '#f0d9b5');// default color
    };

    var removLastMoveHighlighting = function () {
        boardEl.find('.highlight-captured').removeClass('highlight-captured');
        boardEl.find('.highlight-source').removeClass('highlight-source');
        boardEl.find('.highlight-exchange').removeClass('highlight-exchange');

    };
    var lastMoveId = "";

    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
    var createMoveId = function () {
        return 'xxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxx'.replace(/x/g, function (c) {
            var r = Math.random() * 16 | 0;
            return r.toString(16);
        });
    }; 

    /**
     * returns a random number from the given range
     * @param {any} lower - range start
     * @param {any} upper - range to
     */
    function getRandom(lower, upper) {
        // https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript
        var percent = (Math.random() * 100);
        // this will return number between 0-99 because Math.random returns decimal number from 0-0.9929292 something like that
        //now you have a percentage, use it find out the number between your INTERVAL :upper-lower 
        var num = ((percent * (upper - lower) / 100));
        //num will now have a number that falls in your INTERVAL simple maths
        num += lower;
        //add lower to make it fall in your INTERVAL
        //but num is still in decimal
        //use Math.floor>downward to its nearest integer you won't get upper value ever
        //use Math.ceil>upward to its nearest integer upper value is possible
        //Math.round>to its nearest integer 2.4>2 2.5>3   both lower and upper value possible
        // console.log("upper: %s,lower: %s, num: %s, floor num: %s, ceill num: %s, round num: %s", lower, upper, num, Math.floor(num), Math.ceil(num), Math.round(num));
        return Math.floor(num);
    }

    /**
      * Identifies the local player role based on the app state
      */
    function getLocalPlayerRole() {
        if (appClientState == null || appClientState.player == null) return "null";
        if (appClientState.player.IsSpectator) return "Spectator";

        if (appClientState.player.IsAttacker) return "Attacker";
        else
            return "Defender";
    }

    /**
     * @returns the computer role in the current game
     */
    function getComputerRole() {
        if (appClientState.opponentPlayer == null)
            return "null appClientState.opponentPlayer";

        if (appClientState.opponentPlayer.IsAttacker) return "Attacker";
        else 
            return "Defender";
    }

    /**
     * Checks the board and play a move if its the computer turn
     * @param {any} requiredFromPiece -- piece to use as the from 
     */
    function checkBoardAndPlayIfComputer(requiredFromPiece) {
        if (appClientState.player == null) {
            console.log("%s - checkBoardAndPlayIfComputer (as %s) - game turn: %s - local player is null - returning",
                getLoggingNow(), getComputerRole(), game.turn());
            return;
        }
        if (game.turn() == 'a' && appClientState.player.IsAttacker === true) {
            boardEl.removeClass("turn-disabled");
            boardEl.prop('disabled', false);
            console.log("%s - checkBoardAndPlayIfComputer (as %s)- game turn: %s - local real player role is: %s - returning",
                getLoggingNow(), getComputerRole(), game.turn(), getLocalPlayerRole());

            return;
        }

        if (game.turn() == 'd' && appClientState.player.IsAttacker === false) {
            boardEl.removeClass("turn-disabled");
            boardEl.prop('disabled', false);
            console.log("%s - checkBoardAndPlayIfComputer (as %s)- game turn: %s - local real player role is: %s - returning",
                getLoggingNow(), getComputerRole(), game.turn(), getLocalPlayerRole());
            return;
        }

        boardEl.addClass("turn-disabled");
        boardEl.prop('disabled', true);
        if (appClientState.player.IsSpectator || appClientState.opponentPlayer == null) {
            console.log("%s - checkBoardAndPlayIfComputer (as %s)- game turn: %s - local real player is spectator or opponent player is null - returning",
                getLoggingNow(), getComputerRole(), game.turn());

            return;
        }
        // check opponent player is system 
        if (appClientState.opponentPlayer.IsSystem == false) {
            console.log("%s - checkBoardAndPlayIfComputer (as %s)- game turn: %s - opponent player is not system. Local player id: %s",
                getLoggingNow(), getComputerRole(), game.turn(), getLocalPlayerRole());

            return;
        }

        // the game is not set
        if (appClientState.serverGameId == "") {
            console.log("%s - checkBoardAndPlayIfComputer (as %s)- game turn: %s - Null Server Game ID. Local player id: %s",
                getLoggingNow(), getComputerRole(), game.turn(), getLocalPlayerRole());
            return;
        }
        console.log("%s - checkBoardAndPlayIfComputer (as %s) - game turn: %s - local real player is: %s - required From Piece: %s",
            getLoggingNow(), getComputerRole(), game.turn(), getLocalPlayerRole(), requiredFromPiece);


        if (appClientState.opponentPlayer.IsAttacker === true && game.turn() == 'a') {
           // $('#message').html("<div class='alert alert-warning'>Thinking... </div>");
            setTimeout(computer_play, 5000, requiredFromPiece);// ask the system to play after a couple of seconds
        }
        else {
            if (appClientState.opponentPlayer.IsAttacker === false && game.turn() == 'd') {
             //   $('#message').html("<div class='alert alert-warning'>Thinking... </div>");
                setTimeout(computer_play, 5000, requiredFromPiece);// ask the system to play after a couple of seconds
            }
            else
                console.log("%s - checkBoardAndPlayIfComputer (as %s) - game turn: %s - local real player is: %s - required From Piece: %s -- did not trigger play",
                    getLoggingNow(), getComputerRole(), game.turn(), getLocalPlayerRole(), requiredFromPiece);
        }
    }

    /**
     * Generates a computer setting or move
     * @param {string} requiredFromPiece - piece to use for moving
     */
    function computer_play(requiredFromPiece) {
        console.log("%s - computer_play() as %s - required From Piece: %s", getComputerRole(), getLoggingNow(), requiredFromPiece);


        if (game.turn() == 'a' && appClientState.player.IsAttacker === true) {
            boardEl.removeClass("turn-disabled");
            boardEl.prop('disabled', false);
            console.log("%s - computer_play() (as %s)- game turn: %s - local real player role is: %s - returning",
                getLoggingNow(), getComputerRole(), game.turn(), getLocalPlayerRole());

            return;
        }

        if (game.turn() == 'd' && appClientState.player.IsAttacker === false) {
            boardEl.removeClass("turn-disabled");
            boardEl.prop('disabled', false);
            console.log("%s - ccomputer_play() (as %s)- game turn: %s - local real player role is: %s - returning",
                getLoggingNow(), getComputerRole(), game.turn(), getLocalPlayerRole());
            return;
        }

        appClientState.computer_is_playing = true;

        var source = "";
        var target = "";
        var exchangeRequest = false;  // default to true for computer if playing unreachable pieces
        if (game.is_in_setting_state()) {
            var settings = [];
            if (playOptions.firstSettingMustIncludeMalhaAdjacent && appClientState.firstComputerSetting == true && appClientState.opponentPlayer.IsAttacker) {
                settings = game.settings_near_malha(); // cells adjacent to Malha
            }
            else {
                temp_settings = game.settings_near_opponent();

                if (appClientState.opponentPlayer.IsAttacker) {
                    var settings2 = game.settings_near_malha();
                    // check if settings includes any of these and prefer to set on these 
                    for (var si = 0; si < settings2.length; si++) {
                        if (temp_settings.indexOf(settings2[si]) > 0)
                            settings.push(settings2[si]);
                    }
                }
                if (settings.length == 0) { // if none are left check prefer these next ones
                    var settings3 = ['d1', 'e1', 'c1', 'a5', 'a4', 'a3', 'c7', 'd7', 'e7', 'g5', 'g4', 'g3', 'b5', 'c6', 'b3', 'c2', 'e2', 'f3', 'e6', 'f5'];
                    // check if settings includes any of these and prefer to set on these 
                    for (var si = 0; si < settings3.length; si++) {
                        if (temp_settings.indexOf(settings3[si]) > 0)
                            settings.push(settings3[si]);
                    }
                    if (settings.length == 0)
                        settings = temp_settings;
                } 
           
            }
            if (settings.length == 0)  // whatever is left
                settings = game.settings();

            if (settings== null || typeof settings.length === "undefined" || settings.length <= 0) {
              //  $('#message').html("<div class='alert alert-error'>Unable to find a valid setting</div>");

                // if computer can not play -- resign or pass
                game.check();
                appClientState.computer_is_playing = false;
                return;
            }
            soruce = "spare";

            if (playOptions.randomSetting) {
                var settingId = getRandom(0, settings.length - 1);
                target = settings[settingId];
            }
            else
                target = settings[0];

            appClientState.firstComputerSetting = false;
            console.log("%s - Generated computer setting:  %s", getLoggingNow(), target);
        }
        else {
            if (game.is_in_moving_state()) {
                var moves = null;
                if (playOptions.searchMovesThatCaptureOpponent) {
                    moves = game.moves_that_capture(requiredFromPiece);
                }
                if (playOptions.searchMovesThatSaveSelf) {
                    var movesThatSave = game.moves_that_save(requiredFromPiece);

                    if (!playOptions.preferMovesThatCaptureOverMovesThatSave && movesThatSave.length > 0)
                        moves = movesThatSave;
                }

                if (moves == null || moves.length == 0) {  // no capture able and no savable
                    moves = game.moves_unreachables(requiredFromPiece);
                    if (moves != null && moves.length > 0)
                        exchangeRequest = true;
                }

                if (moves == null || moves.length == 0) { // no unreachable?{
                    moves = game.moves(requiredFromPiece);
                }

                
                if (moves == null || typeof moves.length === "undefined" || moves.length <= 0) {
                 //   $('#message').html("<div class='alert alert-danger'>Unable to find a valid move - Contact Support!</div>");

                    // if computer can not play -- resign or pass
                    game.check();
                    appClientState.computer_is_playing = false;
                    return;
                }
                
                var moveId = 0;
                if (playOptions.randomMove)
                    moveId = getRandom(0, moves.length - 1);

                // todo -- add check for game to rank the moves by score and play the one with the highest score

                var move = moves[moveId];
                source = move.From;
                target = move.To;
                console.log("%s - Generated computer move from %s to %s", getLoggingNow(), source, target);
            }
        }

        
        // check if a given source piece must be played
        if (typeof (requiredFromPiece) != 'undefined' && requiredFromPiece != null && requiredFromPiece.length != 0 && source !== requiredFromPiece) {
          //  computer_play(requiredFromPiece); // find another move
            appClientState.computer_is_playing = false;
            return;
        }


        $('#gameMove').html(source + "-" + target);
      

        var ret = false;

        var msg = "";

        var resigned = $('#abandonCheckbox').is(':checked');
        var isAttacker = false;
        if (game.turn() == 'a') {
            // set the exchange request if computer
   //         exchangeRequest = $('#exchangeRequestAcceptedCheckbox').is(':checked');
            isAttacker = true;
        }
        else {
   //         exchangeRequest = $('#exchangeRequestCheckbox').is(':checked');
        }
        var isSetting = false;

        var beforeFEN = game.fen();

        if (game.is_in_moving_state()) {
            ret = game.processMove(source, target, resigned, exchangeRequest);
        }
        else {
            if (game.is_in_setting_state()) {
                isSetting = true;
                ret = game.processSetting(target);
            }
            else {
                ret = false;
            }
        }

        if (ret == true) {

            lastMoveId = createMoveId();
            // submit to the server
            if (appClientState.serverGameId != "" && appClientState.useServer) {
                // notify server pf the setting
            /*    gamesHubProxy.server.recordMove(appClientState.serverGameId, appClientState.opponentPlayer.Name,
                    isAttacker, isSetting, source, target, resigned, exchangeRequest, beforeFEN, game.fen(), msg, lastMoveId,
                    lastMove.captured, lastMove.exchanged
                ).done(function () {
                    console.log('%s - Done Server Invocation of recoredMove ( moveId : %s) inside computer_play - for opponent player %s',
                        getLoggingNow(), lastMoveId, appClientState.opponentPlayer.Name);

                    board.position(game.fen(), false); // update the board with the computer move

                    playSound();

                }).fail(function (error) {
                    console.log('%s - Invocation of recordMove ( moveId : %s) failed. Error: %s', getLoggingNow(), lastMoveId, error);
                });
             */
            }
            else { 

                board.position(game.fen(), false); // update the board with the computer move
                playSound();
            }
        }

        appClientState.computer_is_playing = false;
    }

    /**
     * Updates the board position with the local given game position
     * @param {any} aGame -- the game to use to update the board with
     */
    function updateBoard(aGame) {
        if (aGame == null) {
            console.log("updateBoard - null aGame");
            return;
        }

        if (board !== null) {

            // update the board position here for the case when processing exchanges
            board.position(aGame.fen(), true);
            updateBoardInfo();
        }


        /* TODO: revise based on the local game status
        if (appClientState.serverGame != null) {
            // see if we have a server game that is joined
            if (appClientState.serverGame.Status == 0) {
           //     $('#message').html("<div class='alert alert-warning'>Game is still in pending state for another player to join.</div>");
                boardEl.css('borderColor: warning');
            }
            else {
                if (appClientState.serverGame.Status == 1) {
                  //  $('#message').html("<div class='alert alert-success'>Game is joined by another player.</div>");
                  // enable it
                    boardEl.css('borderColor: green');
                }
                else {
                    $('#message').html("<div class='alert alert-info'><strong>Game Over.</strong></div>");
                    boardEl.css('borderColor: red');
                }
            }
        }
        */

    }

    function clearLastMoveInfo() {
        $('#gameMove').empty();
        $('#move-captured').empty();
        $('#move-exchanged').empty();       
    }

    /**
     * Updates the board game scores based on the given game
     * @param {any} aGame - the game info
     */
    function updateScores(aGame) {
        if (aGame === null) {
            console.log("updateScores - null aGame");
            return;
        }
        $('#attacker_score').html(aGame.getAttackerScore().toString());
        $('#defender_score').html(aGame.getDefenderScore().toString());

        $('#state').html(Kharbga.GameState[aGame.getState()]);

        if (board != null) {
            $('#fen').html(board.fen().replaceAll2('/','/ ') );
            $('#pgn').html(board.position().toString());
        }
    }

    /**
     * Updates the board turn info (clock and processing)
     * @param {any} aGame - the game to update
     */
    function updateTurnInfo(aGame) {
        if (aGame == null) {
            console.log("updateScores - null aGame");
            return;
        }
        if (aGame.game_over() && aGame.winner !== null) {
            if (aGame.winner.IsAttacker()) {
                $('#attacker-thinking').html("WON");
                $('#defender-thinking').html("LOST");
            } else {
                $('#attacker-thinking').html("LOST");
                $('#defender-thinking').html("WON");
            }
        }
        else {
            if (aGame.turn() === 'a') {
                $('#attacker-thinking').html("<div class='alert alert-warning'><strong> >>> <strong> </div>");
                $('#defender-thinking').html("");
            }
            else {
                $('#attacker-thinking').html("");
                $('#defender-thinking').html("<div class='alert alert-warning'><strong> >>> <strong> </div>");
            }
        }
    }
    /**
     * Updates the board game options with the given game move flags
     * @param {any} moveFlags - the nive fkags
     */
    function updateMoveFlags(moveFlags) {
        $('#exchangeRequestCheckbox').prop('checked', moveFlags.exchangeRequest);
        $('#exchangeRequestAcceptedCheckbox').prop('checked', moveFlags.exchangeRequestAccepted);

        $('#exchangeRequestDefenderPiece').text(moveFlags.exchangeRequestDefenderPiece);
        $('#exchangeRequestAttackerPiece1').text(moveFlags.exchangeRequestAttackerPiece1);
        $('#exchangeRequestAttackerPiece2').text(moveFlags.exchangeRequestAttackerPiece2);

        if (!moveFlags.exchangeRequest)
            boardEl.find('.highlight-exchange').removeClass('highlight-exchange');
        else{
            var exchangedSquare = boardEl.find('.square-' + moveFlags.exchangeRequestDefenderPiece);
            exchangedSquare.addClass('highlight-exchange');
        }

        if (!moveFlags.exchangeRequestAccepted)
            boardEl.find('.highlight-exchange').removeClass('highlight-exchange');


        exchangedSquare = boardEl.find('.square-' + moveFlags.exchangeRequestAttackerPiece1);
        exchangedSquare.addClass('highlight-exchange');
        exchangedSquare = boardEl.find('.square-' + moveFlags.exchangeRequestAttackerPiece2);
        exchangedSquare.addClass('highlight-exchange');

        selectedSquare = boardEl.find('.square-' + appClientState.selectedSource);
        selectedSquare.addClass('highlight-move');
    }
    
    /**
     * The main entry point for creating a new game
     */
    function onNewGame(e) {
        if (e === null || e.data === null) {
            $('#message').html("<div class='alert alert-danger'>onNewGame - Invalid arguments</div>");
            return false;
        }
       
        resetLocalGame();
        /*  
         *  if (gamesHubProxy == null) {
            $('#message').html("<div class='alert alert-danger'>Not connected to server</div>");
            return;
        }
        if (appClientState.useServer === true) {
            // call the server to start the new game
            gamesHubProxy.server.createGame(appClientState.userScreenName, e.data.asAttacker, e.data.againstComputer)
                .done(function () {
                    console.log('%s - Done Server Invocation of create game', getLoggingNow());

                }).fail(function (error) {
                    console.log('%s - Invocation of createGame failed. Error: %s', getLoggingNow(), error);
                });
        }
*/
    }

    /**
     * Clears the local game and board 
     */
    function resetLocalGame() {
        // create a new instance for the local game
        // delete game;         
        game = new Kharbga.Game(gameEvents, boardEvents);

        appClientState.loaded = false;
        appClientState.serverGameId = "";

        gameState.firstComputerSetting = true;
        game.reset();
        game.start();
        $('#state').html(Kharbga.GameState[game.getState()]);
        if (board != null) {
            board.clear();
            board.start();
            $('#fen').html(board.fen());
            $('#pgn').html(board.position().toString());
        }

        updateScores(game);

        $('#loadSetting1Btn').show();
        //  $('#startGameBtn').hide();
        boardEl.find('.highlight-captured').removeClass('highlight-captured');
        boardEl.find('.highlight-source').removeClass('highlight-source');
        boardEl.find('.highlight-exchange').removeClass('highlight-exchange');
        boardEl.find('.square-d4').addClass('highlight-malha');

        clearLastMoveInfo();
        removLastMoveHighlighting();
        $('#abandonCheckbox').prop('checked', false);

        setCookie("_nsgid", "");

        // hide the panel (?)
      //  $('#currentGamePanel').hide();
        _soundToggle();

    }
    /**
     * Loads a sample game setting
     */
    function onLoadSetting1() {
        var fen = "SssSsss/sSSSSSS/ssSsSss/sss1sSS/sSsSSSS/SssSsSS/SssSsSs";
        game = new Kharbga.Game(gameEvents, boardEvents);
        game.reset();
        game.start();
        board.clear();
        board.start();
    
        game.set(fen);
        board.position(game.fen(), false);

        $('#state').html(Kharbga.GameState[game.getState()]);
        $('#fen').html(board.fen());
        $('#pgn').html(board.position().toString());

        $('#loadSetting1Btn').hide();
    }
    /**
     * Clears the game and the board. The board is a set with an empty position string or fen
     */
    function onClear() {
        game = new Kharbga.Game(gameEvents, boardEvents);
        game.reset();
        game.start();
        $('#state').html(Kharbga.GameState[game.getState()]);
        board.clear();

        $('#fen').html(board.fen());
        $('#pgn').html(board.position().toString());

        onStart();
    }
  

    $('#new-game').on('click', { asAttacker: true, againstComputer: false }, onNewGame);
    $('#new-game-attacker').on('click', {asAttacker: true, againstComputer:false}, onNewGame);
    $('#new-game-defender').on('click', { asAttacker: false, againstComputer: false },onNewGame);
    $('#new-game-attacker-system').on('click', { asAttacker: true, againstComputer: true }, onNewGame);
    $('#new-game-defender-system').on('click', { asAttacker: false, againstComputer: true}, onNewGame);
   
    $('#loadSetting1Btn').on('click', onLoadSetting1);
    $('#flipOrientation').on('click', this.flipBoard);// flip the board
    $('#exchangeRequestCheckbox').on('click', function () {
        var checked = $('#exchangeRequestCheckbox').is(':checked');
        if (!checked) {           
            $('#exchangeRequestDefenderPiece').text('');
        }
    });
    $('#exchangeRequestAcceptedCheckbox').on('click', function () {
        var checked = $('#exchangeRequestAcceptedCheckbox').is(':checked');
        if (!checked) {
            $('#exchangeRequestAttackerPiece1').text('');
            $('#exchangeRequestAttackerPiece2').text('');
        }
    });

    /**
     * handle for when a move is recorded by the server
     * @param {any} status -- move status
     * @param {any} errorMessage -- error message if move failed to record
     * @param {any} gameServerInfo -- the server game
     * @param {any} player -- the player making the move
     * @param {any} isAttacker -- indicates if attacker move
     * @param {any} isSetting  -- indicates if setting or move
     * @param {any} moveFrom  -- from location
     * @param {any} moveTo   -- to location
     * @param {any} resigned  -- indicates player resigned
     * @param {any} exchangeRequest -- indicates an exchange request or acceptance
     * @param {any} beforeFEN  -- board state before the move
     * @param {any} afterFEN    -- board state after the move
     * @param {any} message  -- the message posted by the player with the move
     * @param {any} serverMove -- the server move record with/ captured/exchange info
     */
    var onMoveRecorded = function (status, errorMessage, gameServerInfo, player, isAttacker, isSetting, moveFrom, moveTo, resigned,
            exchangeRequest, beforeFEN, afterFEN, message, serverMove) {
        if (status === false) {
            console.log("%s - server - error recording move: %s ", getLoggingNow(), errorMessage);
            $('#message').html("<div class='alert alert-danger'> Failed to process move by the server. Error: " + errorMessage+ "</div>");
            return;
        }
        if (serverMove == null) {
            console.log("%s - server - error recording move - invalid game move passed", getLoggingNow());
            $('#message').html("<div class='alert alert-danger'> Server Record Move - Invalid Game Move </div>");
            return;
        }
      
        // check the game and the player
        if (gameServerInfo == null) {
            console.log("%s = server - error recording move - invalid game passed", getLoggingNow());
            $('#message').html("<div class='alert alert-danger'> Server Record Move - Invalid Game </div>");
            return;
        }

        appClientState.serverGame = gameServerInfo; // latest game info (it could get big!)

        if (player == null) {
            console.log("%s - server - error recording move - invalid player passed", getLoggingNow());
            $('#message').html("<div class='alert alert-danger'> Server Record Move - Invalid Player </div>");
            return;
        }

        // if the move is already submitted to the local game (by real player or computer) just add to the Move history and 
        if (lastMoveId === serverMove.ClientID) {
            // append the move to the game history
            appendMoveToGameHisotryList(serverMove);
            console.log("%s - server - did not record setting/move in local game for local moveId: %s", getLoggingNow(), lastMoveId);
            return; 
        }
    
        var ret;
        console.log("%s - server - recording setting/move in local game for server Move ID: %s", getLoggingNow(), serverMove.ClientID);

        if (game.is_in_moving_state()) {
            ret = game.processMove(moveFrom, moveTo, resigned, exchangeRequest);
        }
        else {
            ret = game.processSetting(moveTo);
        }
        updateBoard(game);
        updateLastActionInfo(serverMove);
        if (ret == true)
            playSound();
        else {
            // play error sound
        }

        // append the move to the game history
        appendMoveToGameHisotryList(serverMove);
    }


    /**
     * returns the status text based on status code
     * @param {any} status
     */
    function getStatusText(status) {
        switch (status) {
            case 0:
                return "Created";
            case 1:
                return "Joined";
            case 2:
                return "Active";
            case 3:
                return "Completed";
            case 4:
                return "Aborted";
            case 5:
                return "Disconnected";
            default:
                return "Unknown";
        }
    }
    function getStatusCss(status) {
        switch (status) {
            case 0:
                return "list-group-item-warning";
            case 1:
                return "list-group-item-success";
            case 2:
                return "list-group-item-success";
            case 3:
                return "list-group-item-info";
            case 4:
                return "list-group-item-info";
            case 5:
                return "list-group-item-danger";
            default:
                return "list-group-item-danger";
        }
    }

    function updateLastActionInfo(serverMove) {
        $('#gameMove').html(serverMove.From + " - " + serverMove.To);
        $('#move-captured').html(serverMove.Captured);
        $('#move-exchanged').html(serverMove.Exchanged);
    }

    var onAppendMove = function (gameId, move) {
        // double check that this is current move
        appendMoveToGameHisotry(move);
    };

  

  
    function saveGame() {
     //   if (appClientState.userScreenName == game.winner.Name) { // winner gets this honor
     //       gamesHubProxy.server.updateGameState(appClientState.userScreenName, appClientState.serverGame.id,
     //           game.getState(), game.winner.IsAttacker(), game.attackerScore, game.defenderScore);
     //   }
    }

    function updateBoardInfo(){
        if (game.is_in_setting_state() === true)
            boardEl.find('.square-d4').addClass('highlight-malha');
        else
            boardEl.find('.square-d4').removeClass('highlight-malha');

        if (appClientState.serverGame != null) {
            if (appClientState.serverGame.AttackerName == appClientState.userScreenName )
                $('#game-attacker').text(appClientState.serverGame.AttackerName + " (me)" );
            else
                $('#game-attacker').text(appClientState.serverGame.AttackerName);

            if (appClientState.serverGame.DefenderName == appClientState.userScreenName)
                $('#game-defender').text(appClientState.serverGame.DefenderName + " (me)" );
            else
                $('#game-defender').text(appClientState.serverGame.DefenderName );
        }
        //      
        updateScores(game);

        // update the move flags
        updateMoveFlags(game.move_flags());
        updateTurnInfo(game);

    }

    function resizeGame(e) {

        if (board == null)
            return;

        board.resize(e);
       // $('#currentGamePanel').nsScrollTo();

        updateBoardInfo();
    }
    // handler for resizing
    $(window).resize(resizeGame);

    setupFormsValidation();

    function playSound() {
        var sound = document.getElementById('sound');
        if (sound != null && typeof(sound) != 'undefined')
            sound.play();
    }
    // call to initialize the board after creating the object
    this.initBoard = function (config) {
        var cfg = {
            draggable: config.draggable,
            position: 'start',
            onDragStart: onDragStart,
            //  onDragMove: onDragMove,
            onMoveEnd: onMoveEnd,
            onDrop: onDrop,
            onClick: onClick,
        //    onDoubleClick: onDoubleClick,
        //    onMouseoutSquare: onMouseoutSquare,
        //    onMouseoverSquare: onMouseoverSquare,

            sparePieces: true,
            showErrors: 'console',
            //showErrors
            pieceTheme: config.themePath

        };
        board = KharbgaBoard('board', cfg);
        boardEl = $('#board');
        $('#currentGamePanel').hide();
        
    };

    this.flipBoard = function () {
        if (board === null) {
            $('#message').html("<div class='alert alert-danger'>Game board is not initialized</div>")
            return;
        }
        board.flip();
        updateBoardInfo();       
    };
    
    // setup the current games and last game if any 
    this.setup = function () {
       // rejoinLastGameIfAny();

    };
       
    /*
     * main entry point for creating a new game from the client app
     */ 
    this.newGame = function (options) {
        var event = { data: options };
        onNewGame(event); // 
    };


    this.getCurrentGame = function () {
        // 
        return appClientState.serverGame;
    };

    this.getCurrentState = function () {
        // 
        return appClientState;
    };

    var updateBoardWithMove = function (move, highlightMove) {
        if (move === null)
            return;

        boardEl.find('.highlight-move').removeClass('highlight-move');
        boardEl.find('.highlight-captured').removeClass('highlight-captured');
        if (!move.ExchangeRequest)
            boardEl.find('.highlight-exchange').removeClass('highlight-exchange');

        if (move.IsSetting) {
            boardEl.find('.square-d4').removeClass('highlight-malha');
            boardEl.find('.square-d4').addClass('highlight-malha');
            if (highlightMove === true)
                boardEl.find('.square-' + move.To).addClass('highlight-move');
        }
        else {
            boardEl.find('.square-d4').removeClass('highlight-malha');
            if (highlightMove === true) {
                boardEl.find('.square-' + move.From).addClass('highlight-move');
                if (!move.ExchangeRequest)
                    boardEl.find('.square-' + move.To).addClass('highlight-move');
                else
                    boardEl.find('.square-' + move.To).addClass('highlight-exchange');

                var capturedCells = move.Captured.split(' ');

                if (capturedCells != null) {
                    $.each(capturedCells, function (item, value) {
                        boardEl.find('.square-' + value).addClass('highlight-captured');
                    });
                }

                var exchangedCells = move.Exchanged.split(' ');

                if (exchangedCells != null) {
                    $.each(exchangedCells, function (item, value) {
                        boardEl.find('.square-' + value).addClass('highlight-exchange');
                    });
                }
            }
        }
    
        $('#play-move-player').html(move.PlayerName + " (" + (move.IsAttacker ? "Attacker": "Defender") + ")");
        $('#play-move-number').html(move.Number + " of " + appClientState.serverGame.Moves.length);
 

        var html = "";
        if (move.IsSetting) {
            html += "Set: " + move.To; 
        }else {
            html += "Move: " + move.From + "-" + move.To; 
        }
        if (move.ExchangeRequest) {
            if (move.IsAttacker)
                html += " - Exchange request Accepted";
            else
                html += " - Exchange request";
        }

        if (move.Captured != "") {
            html += " - Captured: " + move.Captured;
        }

        if (move.Exchanged != "") {
            html += " - Exchanged: " + move.Exchanged;
        }
        if (move.Resigned) {
            if (move.IsAttacker)
                html += " - Attacker Resigned";
            else
                html +=" - Defender Resigned" ;
        }

        $('#play-move-info').html(html);
        playSound();
       
    };

    this.playBegining = function () {
        console.log("playBegining");
        if (appClientState.serverGame == null)
            return;

    //    if (appClientState.serverGame.Status != 3)
    //        return;
       
        // we now have a completed game
        console.log("playBegining - status: %s - Last replay Position: %s",
            appClientState.serverGame.Status, appClientState.lastReplayPosition);

        var lastSettingPos = 48;
        if (appClientState.lastReplayPosition > lastSettingPos)
            appClientState.lastReplayPosition = lastSettingPos;
        else
            appClientState.lastReplayPosition = 0;


        board.position(appClientState.serverGame.Moves[appClientState.lastReplayPosition].BeforeFEN, true);

        updateBoardWithMove(appClientState.serverGame.Moves[appClientState.lastReplayPosition], true);
        boardEl.find('.highlight-move').removeClass('highlight-move');

    };
    this.playBackward = function () {
        console.log("playBackward");
        if (appClientState.serverGame == null)
            return;

    //    if (appClientState.serverGame.Status != 3)
    //        return;
        if (appClientState.serverGame.Moves.length == 0)
            return;

        console.log("playBackward - status: %s", appClientState.serverGame.Status);

        appClientState.lastReplayPosition--;
        if (appClientState.lastReplayPosition < 0) {
            appClientState.lastReplayPosition = 0;
            board.position(appClientState.serverGame.Moves[appClientState.lastReplayPosition].BeforeFEN, true);
            updateBoardWithMove(appClientState.serverGame.Moves[appClientState.lastReplayPosition],false);
            return;
        }
        board.position(appClientState.serverGame.Moves[appClientState.lastReplayPosition].AfterFEN, true);
        updateBoardWithMove(appClientState.serverGame.Moves[appClientState.lastReplayPosition],true);

    };
    var replayId = "";
    var replayOn = false;
    this.playStart = function () {
        console.log("playStart");
        if (appClientState.serverGame == null)
            return;

         if (appClientState.serverGame.Status != 3)
              return;

        if (appClientState.serverGame.Moves == null)
            return;

        console.log("playStart - status: %s", appClientState.serverGame.Status);

        if (appClientState.lastReplayPosition < 0)
            appClientState.lastReplayPosition = 0;

        if (appClientState.serverGame.Moves.length == 0) {
            // message
            return;
        }

        if (replayOn)
            return;

        board.position(appClientState.serverGame.Moves[appClientState.lastReplayPosition].AfterFEN, true);
        updateBoardWithMove(appClientState.serverGame.Moves[appClientState.lastReplayPosition], true);
        $('#play-start').attr('class', 'disabled');
        $('#play-pause').attr('class', 'enabled');

        replayId = setInterval(function (playForward) {
            playForward();
        }, 3000, this.playForward);   // add option for replay speed
        replayOn = true;
    };
    this.playPause = function () {
        console.log("playPause");
        if (appClientState.serverGame == null)
            return;

        if (appClientState.serverGame.Status != 3)
            return;

        console.log("playPause - status: %s", appClientState.serverGame.Status);

        clearInterval(replayId);
        replayOn = false;
        $('#play-start').attr('class', 'enabled');
        $('#play-pause').attr('class', 'disabled');

    };
    this.playForward = function () {
        console.log("playForward");
        if (appClientState.serverGame === null)
            return;

    //    if (appClientState.serverGame.Status != 3)
     //       return;

        // we now have a completed game
        console.log("playForward - status: %s - Last replay Position: %s",
            appClientState.serverGame.Status, appClientState.lastReplayPosition);

        appClientState.lastReplayPosition++;
        if (appClientState.serverGame.Moves.length <= appClientState.lastReplayPosition) {
            appClientState.lastReplayPosition = appClientState.serverGame.Moves.length - 1;
            board.position(appClientState.serverGame.Moves[appClientState.lastReplayPosition].AfterFEN, true);
            updateBoardWithMove(appClientState.serverGame.Moves[appClientState.lastReplayPosition],false);
            clearInterval(replayId);
            replayOn = false;
            return;
        }
        board.position(appClientState.serverGame.Moves[appClientState.lastReplayPosition].AfterFEN, true);
        updateBoardWithMove(appClientState.serverGame.Moves[appClientState.lastReplayPosition],true);

    };
    this.playEnd = function () {
        console.log("playEnd");
        if (appClientState.serverGame == null)
            return;

    

        // we now have a completed game
        console.log("playEnd - status: %s - Last replay Position: %s",
            appClientState.serverGame.Status, appClientState.lastReplayPosition);

        var lastSettingPos = 47;
        if (appClientState.lastReplayPosition < lastSettingPos)
            appClientState.lastReplayPosition = lastSettingPos;
        else
            appClientState.lastReplayPosition = appClientState.serverGame.Moves.length - 1

        if (appClientState.serverGame.Moves.length > appClientState.lastReplayPosition)
            appClientState.lastReplayPosition = appClientState.serverGame.Moves.length - 1

        board.position(appClientState.serverGame.Moves[appClientState.lastReplayPosition].AfterFEN, true);
        updateBoardWithMove(appClientState.serverGame.Moves[appClientState.lastReplayPosition], true);

        boardEl.find('.highlight-move').removeClass('highlight-move');

    };
    var soundMuted = false; 
    var _soundToggle = function () {
        var sound = document.getElementById("sound");
        if (sound == null || typeof (sound) == 'undefined')
            return;

        soundMuted = !soundMuted;

        sound.muted = soundMuted;
        $('#sound-mute').removeClass('mute');
        if (soundMuted)
            $('#sound-mute').addClass('mute');

    };
    this.soundToggle = _soundToggle;

    this.soundUp = function () {
        var sound = document.getElementById("sound");
        if (sound == null || typeof (sound) == 'undefined')
            return;

        sound.muted = false;
        var volume = sound.volume;

        volume += 0.2;
        if (volume > 1.0)
            sound.volume = 1.0;
        else
            sound.volume = volume;

    };
    this.soundDown = function () {
        var sound = document.getElementById("sound");
        if (sound == null || typeof (sound) == 'undefined')
            return;

        sound.muted = false;
        var volume = sound.volume;
        volume -= 0.2;

        if (volume < 0.2)
            sound.volume = 0.2;
        else
            sound.volume = volume;
    };

    this.setVolume = function (volume) {
        var sound = document.getElementById("sound");
        if (sound == null || typeof (sound) == 'undefined')
            return;

        var volume2 = $('#sound-volume').val();
        var volumeNumber = Number.parseFloat(volume2);
        sound.muted = false;
        if (volume < 0.2)
            sound.volume = 0.2;
        else
            sound.volume = volumeNumber;
    };
 
}; 
